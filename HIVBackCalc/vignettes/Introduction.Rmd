---
title: "Introduction to HIVBackCalc"
author: "Jeanette Birnbaum"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to HIVBackCalc}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

HIVBackCalc estimates undiagnosed HIV cases based on testing history data from diagnosed persons reporting on when they last had a negative HIV test. HIV diagnoses observed in a given year are the convolution of incidence in prior years and the probability of being diagnosed in that year conditional on infection in a prior year. This package may be used to backcalculate HIV incidence...

The vignette will guide you through a full analysis using a simulated dataset that reflects similar population-level characteristics to the data described in the manuscript.

```{r setup, echo=FALSE, message=FALSE}
#setwd('F:/GitHub/package1.02/HIVBackCalc')

# Setup
#load('data/KCsim.RData')
library(HIVBackCalc)
#source('R/model.R')
#source('R/tid.R')
#source('R/results.R')
#library(reshape2)
#library(ggplot2)
#library(scales)
#library(Hmisc)
#library(plyr)
```

## Testing History Data

### Overview

The example data embedded in the package approximate testing histories collected from HIV diagnoses among MSM in King County, Washington reported in 2006-2012. The following code will load the data into a data frame called `KCsim` and display the first 6 rows.

```{r, echo=TRUE}
data(KCsim)
```

```{r, echo=TRUE, eval=FALSE}
head(KCsim)
```

```{r, echo=FALSE, results='asis'}
knitr::kable(head(KCsim))
```

The necessary variables are: 

1. Age at diagnosis (hdx_age)
    * In the simulated data set, hdx_age is reported in 5 yr intervals.
1. Year of diagnosis (yearDx)
1. Time of diagnosis (timeDx)
    * Defined by the reporting time unit. In the example data, diagnoses are reported quarterly, specified using decimals: 0.00 = Q1 (Jan-Mar), 0.25 = Q2, etc.  So someone diagnosed in the third quarter of 2008 would have timeDX = 2008.75.
1. Testing history (everHadNegTest)
    * Response to "Have you ever had a negative HIV test?"
    * Three possible values:  TRUE, FALSE and <NA>
1. Time from last negative test to diagnosis (infPeriod)
    * If everHadNegTest=FALSE, imputed as the smaller of 18 years, or hdx_age-16.

The remainder of the variables are optional descriptive variables by which the data can be stratified for subgroup analyses.

## Specify Diagnosed Interval Length

The intervals of the `timeDx` variable represent the discrete time unit for reporting cases, and determine the finest interval by which we may estimate incidence and undiagnosed counts. In the example data, this interval is a quarter year (0.25). We will store this in an object to use throughout:


```{r, echo=TRUE, results='asis'}
diagInterval = 0.25
```

This interval maximizes the use of reported information, and defines the unit of analysis for "undiagnosed HIV." Results will be estimated as undiagnosed counts per quarter. Using quarterly reports implies that a diagnosis made within 3 months of infection is acceptable and contributes no "undiagnosed" time. If we used a longer interval, by re-formatting `timeDx`, this would modify the meaning of "undiagnosed" accordingly.

## Estimating the Time from Infection to Diagnosis (TID)

The testing history data provides bounds for the possible infection period or "infPeriod" within which infection must have occurred, for all diagnosed cases that have a prior negative test.  If a case is diagnosed on their first test, there will be no prior negative test (`KCsim$everHadNegTest=FALSE`), and we need an alternative approach to defining the possible infection period.  In the paper, these cases were assigned an infperiod that was the minimum of 18 years or age-16.

The next step is to aggregate these individual infection periods and use them to define a population level probability distribution for the time from infection to diagnosis (TID). This will require making some assumption regarding when infection occurred within the possible infection period.

HIVBackCalc implements the assumptions that define the two "cases" for the TID examined in the paper:

**Base Case** - The probability of acquiring infection is uniformly distributed across the infection period.  This assumes testing is not driven by risk exposure, so is likely to be conservative (i.e., overestimate the time spent undiagnosed).

**Upper Bound** - All infections occur immediately after the last negative test. This is an extremely conservative assumption that represents the maximum possible amount of time people could have been infected but undiagnosed.

The `estimateTID` function will return the probability and cumulative density functions for each of these cases. 
 

```{r, echo=TRUE, results='asis'}
TIDs <- estimateTID(KCsim$infPeriod, intLength=diagInterval)
```

We can examine the TID for each case by plotting the probability and survivor functions. 

```{r, echo=TRUE, results='asis', fig.height=5, fig.width=6.5}
plot(TIDs, intLength=diagInterval, 
     cases = c('Base Case', 'Upper Bound'))
```

The spike in density at 18 years for the **Upper Bound** TID reflects the assumption we made for the cases that were diagnosed at their first test.

We can evaluate the TID at particular time points of interest using the `summary` function. The time points should be specified in years and represent the left bound of the discrete time between infection and diagnosis.

```{r, echo=TRUE, eval=FALSE}
summary(TIDs, intLength=diagInterval,
        cases = c('Base Case', 'Upper Bound'),       
        times =c(0, 0.25, 1, 5, 10, 18))
```

```{r, echo=FALSE, results='asis'}
knitr::kable(summary(TIDs, intLength=diagInterval,
                     cases = c('Base Case', 'Upper Bound'),
                     times =c(0, 0.25, 1, 5, 10, 18)))
```

## Backcalculation of Incidence

To backcalculate incidence, we must define a vector of diagnosis counts per interval. By default, this vector contains 100 empty intervals prior to the first interval in which we observe diagnoses. These empty intervals will indicate to the model how far back to project incidence. 

```{r, echo=TRUE, results='asis'}
diagCounts = tabulateDiagnoses(KCsim, intLength=diagInterval)
```

The backcalculation uses the same diagnosis counts but different TIDs to project incidence for each of the cases.

```{r, echo=TRUE, results='asis', cache=TRUE}
incidenceBase = estimateIncidence(y=diagCounts,
                                  pid=TIDs[['base_case']]$pdffxn,
                                  gamma=0.1,
                                  verbose=FALSE)
incidenceUpper = estimateIncidence(y=diagCounts,
                                  pid=TIDs[['upper_bound']]$pdffxn,
                                  gamma=0.1,
                                  verbose=FALSE)
```

We can plot the backcalculated estimates over time, overlayed by the diagnosis counts in red.

```{r, echo=TRUE, fig.show="hold", fig.width=5, fig.height=5, out.width="325px"}
plot(incidenceBase, case='Base Case')
plot(incidenceUpper, case='Upper Bound')
```

While the TIDs for the two cases are quite distinct, the incidence estimates are almost identical. This is because the diagnosis counts are relatively stable, and the TIDs are constant, not year-specific (this assumption was tested in the paper).  Together, this implies that incidence is approximately equal to diagnosed cases, and both TID cases will conform to this incidence estimate.  The impact of the different TID assumptions is just to recalibrate the fraction of prevalent infections that are diagnosed at any point in time.  People have been undiagnosed for longer in the upper bound case, so the observed diagnoses in this case are estimated to have a greater fraction of persons whose time of infection was further in the past.  This in turn will generate a higher fraction of recently infected persons who are undiagnosed, as we see next.

## Estimation of Undiagnosed Counts

Estimating undiagnosed counts requires applying the TID to the incidence estimates to determine how many of those who were ultimately diagnosed were undiagnosed in a given interval.

```{r, echo=TRUE, eval=TRUE}
# Base Case
undiagnosedBase <- estimateUndiagnosed(incidenceBase)
# Upper Bound
undiagnosedUpper <- estimateUndiagnosed(incidenceUpper)
```



## Examining Results

The results of the two cases can be combined and contrasted by creating a "results" object using `combineResults()`. Note that the names of the upper-level list, e.g. "Base Case" and "Upper Bound", will be used to label the respective results in the results plots and tables that follow.


```{r, echo=TRUE, eval=TRUE}
results <- combineResults(list(`Base Case`=list(incidenceBase,
                                            undiagnosedBase),
                             `Upper Bound`=list(incidenceUpper,
                                              undiagnosedUpper)))
```

The estimates are summarized over all time periods in the `results$resultsSummary` element.

```{r, echo=TRUE, eval=FALSE}
results$resultsSummary
```

```{r, echo=FALSE, results='asis'}
knitr::kable(results$resultsSummary)
```


Plotting the results object will panel the incidence and undiagnosed estimates with the cases overlayed:

```{r, echo=TRUE, eval=TRUE, fig.width=6, fig.height=5, fig.align='center'}
plot(results)
```


## Direct Calculation Assuming Constant Incidence

This simpler method may be used if both HIV incidence and the TID probability distribution are constant over time.

We first define incidence as the average of observed diagnoses (per quarter):

```{r, echo=TRUE}
constantIncidence <- mean(diagCounts, na.rm=TRUE)
```

We can then apply the TID to estimate undiaagnosed counts assuming this constant incidence:

```{r, echo=TRUE, eval=TRUE}
# Base Case
undiagnosedConstBase <- estimateUndiagnosedConst(infPeriod=KCsim$infPeriod,
                                                 case='base_case',
                                                 intLength=diagInterval,
                                                 incidence=constantIncidence)

undiagnosedConstBase

# Upper Bound
undiagnosedConstUpper <- estimateUndiagnosedConst(infPeriod=KCsim$infPeriod,
                                                  case='upper_bound',
                                                  intLength=diagInterval,
                                                  incidence=constantIncidence)

undiagnosedConstUpper

```
